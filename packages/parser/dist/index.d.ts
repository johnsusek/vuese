// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../../../../../@babel/types
//   ../../../../../../@vuese/parser
//   ../../../../../../@babel/traverse

declare module '@vuese/parser' {
    import { CommentResult } from '@vuese/parser/jscomments';
    export * from '@vuese/parser/sfcToAST';
    export * from '@vuese/parser/parseJavascript';
    export * from '@vuese/parser/parseTemplate';
    export * from '@vuese/parser/helper';
    export * from '@vuese/parser/jscomments';
    export type PropType = string | string[] | null;
    /**
      * Since version 7.3.3, `type ParserPlugin` has been added with the `ParserPluginWithOptions` type,
      * which is a breaking change for vuese, so we will force the installation of the version below 7.3.3,
      * and the overall upgrade will follow.
      * https://github.com/babel/babel/blob/master/packages/babel-parser/typings/babel-parser.d.ts#L118
      */
    type ParserPlugin = 'estree' | 'jsx' | 'flow' | 'flowComments' | 'typescript' | 'doExpressions' | 'objectRestSpread' | 'decorators' | 'decorators-legacy' | 'classProperties' | 'classPrivateProperties' | 'classPrivateMethods' | 'exportDefaultFrom' | 'exportNamespaceFrom' | 'asyncGenerators' | 'functionBind' | 'functionSent' | 'dynamicImport' | 'numericSeparator' | 'optionalChaining' | 'importMeta' | 'bigInt' | 'optionalCatchBinding' | 'throwExpressions' | 'pipelineOperator' | 'nullishCoalescingOperator';
    export type BabelParserPlugins = {
        [key in ParserPlugin]?: boolean;
    };
    export interface PropsResult {
        type: PropType;
        name: string;
        typeDesc?: string[];
        required?: boolean;
        default?: string;
        defaultDesc?: string[];
        validator?: string;
        validatorDesc?: string[];
        describe?: string[];
    }
    export interface EventResult {
        name: string;
        isSync: boolean;
        syncProp: string;
        describe?: string[];
        argumentsDesc?: string[];
    }
    export interface MethodResult {
        name: string;
        describe?: string[];
        argumentsDesc?: string[];
    }
    export interface ComputedResult {
        name: string;
        type?: string[];
        describe?: string[];
        isFromStore: boolean;
    }
    export interface MixInResult {
        mixIn: string;
    }
    export interface DataResult {
        name: string;
        type: string;
        describe?: string[];
        default?: string;
    }
    export interface WatchResult {
        name: string;
        describe?: string[];
        argumentsDesc?: string[];
    }
    export type AttrsMap = Record<string, string>;
    export interface SlotResult {
        name: string;
        describe: string;
        backerDesc: string;
        bindings: AttrsMap;
        scoped: boolean;
        target: 'template' | 'script';
    }
    export interface ParserOptions {
        onProp?: {
            (propsRes: PropsResult): void;
        };
        onEvent?: {
            (eventRes: EventResult): void;
        };
        onMethod?: {
            (methodRes: MethodResult): void;
        };
        onComputed?: {
            (computedRes: ComputedResult): void;
        };
        onMixIn?: {
            (mixInRes: MixInResult): void;
        };
        onData?: {
            (dataRes: DataResult): void;
        };
        onSlot?: {
            (slotRes: SlotResult): void;
        };
        onName?: {
            (name: string): void;
        };
        onDesc?: {
            (desc: CommentResult): void;
        };
        onWatch?: {
            (watch: WatchResult): void;
        };
        babelParserPlugins?: BabelParserPlugins;
        basedir?: string;
        jsFile?: any;
        includeSyncEvent?: boolean;
    }
    export interface ParserResult {
        props?: PropsResult[];
        events?: EventResult[];
        slots?: SlotResult[];
        mixIns?: MixInResult[];
        methods?: MethodResult[];
        computed?: ComputedResult[];
        data?: DataResult[];
        watch?: WatchResult[];
        name?: string;
        componentDesc?: CommentResult;
        extraDocs?: string;
    }
    export function parser(source: string, options?: ParserOptions): ParserResult;
}

declare module '@vuese/parser/jscomments' {
    import * as bt from '@babel/types';
    export interface CommentResult {
            default: string[];
            [key: string]: string[];
    }
    /**
        * @param cnode {bt.Node} a node with comments
        * @param trailing {boolean} Whether to process the tailing comment
        */
    export function getComments(cnode: bt.Node, trailing?: boolean): CommentResult;
    /**
        * Extract the leading comments of the default export statement
        * 1、If the default export is a class with a decorator,
        *    we should find the trailing comments of the last decorator node.
        * 2、In other cases, directly use the leading commets of the default export statement.
        */
    export function getComponentDescribe(node: bt.ExportDefaultDeclaration): CommentResult;
    export function isCommentLine(node: {
            type: string;
    }): boolean;
    export function isCommentBlock(node: {
            type: string;
    }): boolean;
    export function isCodeBlockDeclaration(value: string): boolean;
    export function filterBlockComments(comments: string[]): string[];
}

declare module '@vuese/parser/sfcToAST' {
    import { BabelParserPlugins } from '@vuese/parser';
    import * as bt from '@babel/types';
    export interface AstResult {
        sourceType?: string;
        jsAst?: bt.File;
        templateAst?: object;
        jsSource: string;
        templateSource: string;
        docSource: string;
    }
    export function sfcToAST(source: string, babelParserPlugins?: BabelParserPlugins, basedir?: string, jsFile?: boolean): AstResult;
}

declare module '@vuese/parser/parseJavascript' {
    import { NodePath } from '@babel/traverse';
    import * as bt from '@babel/types';
    import { ParserOptions } from '@vuese/parser';
    import { Seen } from '@vuese/parser/seen';
    export function parseJavascript(ast: bt.File, seenEvent: Seen, options: ParserOptions, source?: string): void;
    export function processEmitCallExpression(path: NodePath<bt.CallExpression>, seenEvent: Seen, options: ParserOptions, parentExpressionStatementNodePath: NodePath<bt.Node>): void;
}

declare module '@vuese/parser/parseTemplate' {
    import { ParserOptions } from '@vuese/parser';
    import { Seen } from '@vuese/parser/seen';
    export function parseTemplate(templateAst: any, seenEvent: Seen, options: ParserOptions): void;
}

declare module '@vuese/parser/helper' {
    import { NodePath } from '@babel/traverse';
    import * as bt from '@babel/types';
    /**
      * If a node satisfies the following conditions, then we will use this node as a Vue component.
      * 1. It is a default export
      * 2. others...
      */
    export function isVueComponent(path: NodePath, componentLevel: number): boolean;
    export function isVueOption(path: NodePath<bt.ObjectProperty> | NodePath<bt.ObjectMethod>, optionsName: string, componentLevel: number): boolean;
    export function runFunction(fnCode: bt.Node): any;
    export function getValueFromGenerate(node: any): any;
    export function computesFromStore(node: any): boolean;
    export function getLiteralValue(node: bt.Node): string;
}

declare module '@vuese/parser/seen' {
    export class Seen {
        seenSet: Set<unknown>;
        seen(label: string): boolean;
    }
}

